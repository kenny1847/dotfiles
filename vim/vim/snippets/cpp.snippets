# license
snippet apache-2.0
	/*
	 * Copyright 2017 Danil Dulin
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 *     http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 */

##
## Preprocessor
# header include guard
snippet guard
	#pragma once

snippet once
	#ifndef ${1:FILENAME}
	#define $1

	${0}

	#endif // $1
snippet inc
	#include <${1}>
##
## Main
snippet main
	int main(int argc, char** argv) {
		${VISUAL}${0}
		return 0;
	}
##
## Control Statements
# if
snippet if
	if (${1:true}) {
		${0:${VISUAL}}
	}
snippet ife
	if (${1:true}) {
		${2:${VISUAL}}
	} else {
		${0}
	}
# else
snippet else
	else {
		${0:${VISUAL}}
	}
# else if
snippet elif
	else if (${1:true}) {
		${0:${VISUAL}}
	}
# ternary
snippet ter
	${1:/* condition */} ? ${2:a} : ${3:b}
# switch
snippet switch
	switch (${1:/* variable */}) {
		case ${2:/* variable case */}:
			${3}
			${4:break;}${5}
		default:
			${6}
	}
# case
snippet case
	case ${1:/* variable case */}:
		${2}
		${3:break;}
snippet ret
	return ${1};
## Loops and Iteration
# for i
snippet fori
	for (size_t ${2:i} = 0; $2 < ${1:count}; ${3:++}$2) {
		${4}
	}
# foreach
snippet fore
	for (${1:auto} ${2:i} : ${3:container}) {
		${4}
	}
# iterator
snippet forit
	for (${1:std::vector}<${2:type}>::${3:const_iterator} ${4:i} = ${5:container}.begin(); $4 != $5.end(); ++$4) {
		${6}
	}
# auto iterator
snippet forit
	for (auto ${1:i} = ${2:container}.begin(); $1 != $2.end(); ++$1) {
		${3:std::cout << *$1 << std::endl;}
	}
# while
snippet while
	while (${1:/* condition */}) {
		${0:${VISUAL}}
	}
# do... while
snippet do
	do {
		${0:${VISUAL}}
	} while (${1:/* condition */});
##
## Functions
# function declaration
snippet fund
	${1:void} ${2:function_name}(${3});
# function definition
snippet fun
	${1:void} ${2:function_name}(${3}) {
		${4}
	}
# member function definition
snippet mfun
	${4:void} ${1:ClassName}::${2:memberFunction}(${3}) {
		${0}
	}
##
## Namespaces
# namespace
snippet ns
	namespace ${1} {
		${0}
	} /* namespace $1 */
# using namespace
snippet usn
	using namespace ${1};
##
## Types and aliasing
# using
snippet us
	using ${1:name} = ${2:type-id};
# template using
snippet ust
	template <typename ${3:T}>
	using ${1:name} = ${2:type-id};
# typedef
snippet td
	typedef ${2:int} ${1:MyCustomType};
# class
snippet cl
	class ${1:name} {
	public:
		$1();
		~$1();

	private:
		${2}
	};
# struct
snippet st
	struct ${1:name} {
		${2}
	};
# enum
snippet enum
	enum ${1:name} {
		${2}
	};
# scoped enum
snippet enumc
	enum class ${1:name} ${2:: uint8_t} {
		${3}
	};
# T* arg
snippet ptr
	${1:T}* ${2:arg}
# const T* arg
snippet cptr
	const ${1:T}* ${2:arg}
# T& arg
snippet ref
	${1:T}& ${2:arg}
# const T& arg
snippet cref
	const ${1:T}& ${2:arg}
##
## Casts
# static
snippet sc
	static_cast<${1:unsigned}>(${2:expr})${3}
# static pointer
snippet spc
	static_pointer_cast<${1:unsigned}>(${2:expr})${3}
# dynamic
snippet dc
	dynamic_cast<${1:unsigned}>(${2:expr})${3}
# dynamic pointer
snippet dpc
	dynamic_pointer_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret
snippet rc
	reinterpret_cast<${1:unsigned}>(${2:expr})${3}
# reinterpret pointer
snippet rpc
	reinterpret_pointer_cast<${1:unsigned}>(${2:expr})${3}
# const
snippet cc
	const_cast<${1:unsigned}>(${2:expr})${3}
# const pointer
snippet cpc
	const_cpointer_ast<${1:unsigned}>(${2:expr})${3}
##
## STL
# std::shared_ptr<T> arg
snippet sptr
	std::shared_ptr<${1:T}> ${2:arg}
# const std::shared_ptr<T> arg
snippet csptr
	const std::shared_ptr<${1:T}> ${2:arg}
# const std::shared_ptr<T>& arg
snippet csptrr
	const std::shared_ptr<${1:T}>& ${2:arg}
# std::weak_ptr<T> arg
snippet wptr
	std::weak_ptr<${1:T}> ${2:arg}
# std::unique_ptr<T> arg
snippet uptr
	std::unique_ptr<${1:T}> ${2:arg}
# std::unique_ptr<T>& arg
snippet uptrr
	std::unique_ptr<${1:T}>& ${2:arg}
# const std::unique_ptr<T> arg
snippet cuptr
	const std::unique_ptr<${1:T}> ${2:arg}
# const std::unique_ptr<T>& arg
snippet cuptrr
	const std::unique_ptr<${1:T}>& ${2:arg}
# std::experimental::optional<T> arg
snippet opt
	std::experimental::optional<${1:T}> ${2:arg}
# std::make_shared
snippet mks
	std::make_shared<${1:T}>(${2});
# std::make_unique
snippet mku
	std::make_unique<${1:T}>(${2});
# std::make_optional
snippet mko
	std::make_optional(${1});
# std::make_pair
snippet mkp
	std::make_pair<${1:T1}, ${2:T2}>(${3});
# std::string
snippet str
	std::string
# std::basic_string<T>
snippet strt
	std::basic_string<CharT>
# std::array
snippet array
	std::array<${1:T}, ${2:N}> ${3};
# std::vector
snippet vector
	std::vector<${1:T}> ${2};
# std::deque
snippet deque
	std::deque<${1:T}> ${2};
# std::forward_list
snippet flist
	std::forward_list<${1:T}> ${2};
# std::list
snippet list
	std::list<${1:T}> ${2};
# std::set
snippet set
	std::set<${1:T}> ${2};
# std::map
snippet map
	std::map<${1:Key}, ${2:T}> ${3};
# std::multiset
snippet mset
	std::multiset<${1:T}> ${2};
# std::multimap
snippet mmap
	std::multimap<${1:Key}, ${2:T}> ${3};
# std::unordered_set
snippet uset
	std::unordered_set<${1:T}> ${2};
# std::unordered_map
snippet umap
	std::unordered_map<${1:Key}, ${2:T}> ${3};
# std::unordered_multiset
snippet umset
	std::unordered_multiset<${1:T}> ${2};
# std::unordered_multimap
snippet ummap
	std::unordered_multimap<${1:Key}, ${2:T}> ${3};
# std::stack
snippet stack
	std::stack<${1:T}> ${2};
# std::queue
snippet queue
	std::queue<${1:T}> ${2};
# std::priority_queue
snippet pqueue
	std::priority_queue<${1:T}> ${2};
##
## Lambdas
# lamda (one line)
snippet ld
	[${1}](${2}){${3}};
# lambda (multi-line)
snippet lld
	[${1}](${2}){
		${3}
	};
##
## Input/Output
# std::cout
snippet cout
	std::cout << ${1} << std::endl;
# std::cin
snippet cin
	std::cin >> ${1};
# printf
snippet pr
	printf("${1:%s}\n"${2});
snippet fpr
	fprintf(${1:stderr}, "${2:%s}\n"${3});
snippet prd
	printf("${1:} = %d\n", $1);
snippet prf
	printf("${1:} = %f\n", $1);
snippet prx
	printf("${1:} = %${2}\n", $1);
